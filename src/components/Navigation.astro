---
import type {INavigation} from "../types/navigation";

interface Props {
	navigation: INavigation[];
	navigationPostion: string;
}

const {navigation} = Astro.props;
const {navigationPostion} = Astro.props;
---

<nav class="navbar">
    <ul>
			{
				navigation.map((item) => {
					return (
                  <li>
                      <a
                              href={
																navigationPostion === "header" ? "#" + item.title : item.title
															}
                              data-href={item.title}
                              aria-current="page"
                      >
												{item.title}
                      </a>
                  </li>
					);
				})
			}
    </ul>
</nav>

<script>
	let scrollTimeout: NodeJS.Timeout | null = null;

	document.addEventListener("DOMContentLoaded", () => {
		initNavigation();
		initIntersectionObserver();
	});

	function initNavigation(): void {
		window.addEventListener('hashchange', updateActiveLink);
		updateActiveLink();
	}

	function updateActiveLink(): void {
		const navigationLinks = document.querySelectorAll<HTMLAnchorElement>('a[data-href]');
		const currentUrl = window.location.hash.substring(1);

		navigationLinks.forEach((link) => {
			let currentLink = link.getAttribute('data-href');
			if (currentLink === '#') {
				currentLink = currentLink.substring(1);
			}

			if (currentLink === currentUrl) {
				link.classList.add("active");
			} else {
				link.classList.remove("active");
			}
		});
	}

	function initIntersectionObserver(): void {
		const observerOptions: IntersectionObserverInit = {
			root: null,
			rootMargin: '0px',
			threshold: 0.5
		};

		const observerCallback: IntersectionObserverCallback = (entries) => {
			entries.forEach(entry => {
				if (entry.isIntersecting) {
					const sectionId = entry.target.id;
					const activeLink = document.querySelector<HTMLAnchorElement>(`a[data-href='${sectionId}']`);

					if (activeLink) {
						// Clear previous scroll timeout
						if (scrollTimeout) {
							clearTimeout(scrollTimeout);
						}

						// Set new timeout to update active link after scrolling stops
						scrollTimeout = setTimeout(() => {
							document.querySelectorAll<HTMLAnchorElement>('a[data-href]').forEach(link => {
								link.classList.remove('active');
							});
							activeLink.classList.add('active');
						}, 200); // Adjust delay time (in milliseconds) as needed
					}
				}
			});
		};

		const observer = new IntersectionObserver(observerCallback, observerOptions);
		document.querySelectorAll<HTMLElement>('section').forEach(section => {
			observer.observe(section);
		});
	}
</script>


<style lang="scss">
  @import "./../styles/GlobalStyling";

  nav {
    align-items: center;

    ul {
      display: flex;
      list-style: none;
      margin: unset;
      padding: unset;

      li {
        margin-right: $spacing-l;
        font-weight: 300;

        &:last-child {
          margin-right: unset;
        }
      }
    }
  }

  .navbar {
    a {
      color: $color-white;
      text-decoration: none;
      text-transform: uppercase;
      font-family: Source Code Pro Variable, sans-serif;
      padding: $spacing-s;

      &.active {
        color: black;
      }

      &:hover {
        color: $color-black;
        background-color: lighten($color-white, 20%);
      }

      &:focus {
        outline: none;

      }
    }
  }

</style>
